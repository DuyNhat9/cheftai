<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CheftAi - Multi-Agent Control Center</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0a0e1a 0%, #1a1f2e 100%);
            color: #ffffff;
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #137FEC 0%, #8B5CF6 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
        }

        .tab {
            padding: 12px 24px;
            background: transparent;
            border: none;
            color: #9dabb9;
            cursor: pointer;
            font-size: 1em;
            border-bottom: 2px solid transparent;
            transition: all 0.3s;
        }

        .tab.active {
            color: #137FEC;
            border-bottom-color: #137FEC;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255, 255, 255, 0.05);
            padding: 15px 20px;
            border-radius: 12px;
            margin-bottom: 30px;
            backdrop-filter: blur(10px);
        }

        .status-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85em;
            font-weight: 600;
        }

        .status-working { background: #10b981; color: white; }
        .status-idle { background: #6b7280; color: white; }
        .status-completed { background: #3b82f6; color: white; }
        .status-pending { background: #f59e0b; color: white; }
        .status-in-progress { background: #8b5cf6; color: white; }

        .agents-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .agent-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 20px;
            backdrop-filter: blur(10px);
            transition: all 0.3s;
        }

        .agent-card.working {
            border-color: #10b981;
            box-shadow: 0 0 20px rgba(16, 185, 129, 0.2);
        }

        .agent-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .agent-name {
            font-size: 1.3em;
            font-weight: 700;
        }

        .agent-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            font-size: 0.9em;
        }

        .btn-primary {
            background: #137FEC;
            color: white;
        }

        .btn-primary:hover {
            background: #0f6fd6;
            transform: translateY(-2px);
        }

        .btn-success {
            background: #10b981;
            color: white;
        }

        .btn-warning {
            background: #f59e0b;
            color: white;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .task-item {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 18px;
            border-left: 4px solid;
            margin-bottom: 15px;
            transition: all 0.3s;
        }

        .task-item:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        .task-item.completed { border-left-color: #10b981; }
        .task-item.in-progress { border-left-color: #8b5cf6; }
        .task-item.pending { border-left-color: #f59e0b; }

        .task-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .trigger-panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 16px;
            padding: 25px;
            margin-bottom: 30px;
            backdrop-filter: blur(10px);
        }

        .trigger-panel h3 {
            margin-bottom: 20px;
            color: #137FEC;
        }

        .trigger-form {
            display: grid;
            gap: 15px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .form-group label {
            font-weight: 600;
            color: #9dabb9;
        }

        .form-group select,
        .form-group input,
        .form-group textarea {
            padding: 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: white;
            font-size: 1em;
        }

        .form-group textarea {
            min-height: 100px;
            resize: vertical;
        }

        .plan-viewer {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 16px;
            padding: 25px;
            backdrop-filter: blur(10px);
        }

        .plan-section {
            margin-bottom: 30px;
        }

        .plan-section h3 {
            color: #137FEC;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
        }

        .plan-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            border-left: 3px solid #137FEC;
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            backdrop-filter: blur(5px);
        }

        .modal {
            background: linear-gradient(135deg, #1a1f2e 0%, #0a0e1a 100%);
            border-radius: 16px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
        }

        .modal-title {
            font-size: 1.5em;
            font-weight: 600;
            background: linear-gradient(135deg, #137FEC 0%, #8B5CF6 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .modal-close {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: #fff;
            width: 32px;
            height: 32px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.2em;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .modal-close:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .modal-body {
            margin-bottom: 20px;
        }

        .task-item {
            padding: 12px 15px;
            margin-bottom: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border-left: 3px solid transparent;
            transition: all 0.2s;
        }

        .task-item:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        .task-item.completed {
            border-left-color: #10b981;
        }

        .task-item.in-progress {
            border-left-color: #8b5cf6;
        }

        .task-item.pending {
            border-left-color: #f59e0b;
        }

        .task-id {
            font-weight: 600;
            color: #137FEC;
            margin-right: 8px;
        }

        .task-title {
            color: #ffffff;
            margin-bottom: 5px;
        }

        .task-status {
            font-size: 0.85em;
            color: #9dabb9;
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            padding-top: 15px;
            border-top: 2px solid rgba(255, 255, 255, 0.1);
        }

        .btn-modal {
            padding: 10px 24px;
            background: linear-gradient(135deg, #137FEC 0%, #8B5CF6 100%);
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-modal:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(19, 127, 236, 0.4);
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            background: #10b981;
            color: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            animation: slideIn 0.3s;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
        }

        .stat-value {
            font-size: 2.5em;
            font-weight: 700;
            margin: 10px 0;
        }

        .refresh-btn {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: #137FEC;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 4px 20px rgba(19, 127, 236, 0.4);
            transition: all 0.3s;
        }

        .refresh-btn:hover {
            transform: rotate(180deg) scale(1.1);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üç≥ CheftAi Multi-Agent Control Center</h1>
            <p>Trigger Agents & Monitor Progress in Real-time</p>
        </div>

        <div class="tabs">
            <button class="tab active" onclick="switchTab('monitor')">üìä Monitor</button>
            <button class="tab" onclick="switchTab('trigger')">üöÄ Trigger Agent</button>
        </div>

        <div class="status-bar">
            <div>Last Update: <span id="lastUpdate">--</span></div>
            <div>Auto-refresh: <span id="autoRefreshStatus">ON (<span id="countdown">5</span>s)</span></div>
            <div>Project: <span id="projectStatus">--</span></div>
        </div>

        <!-- Quick Actions: Step 1 Scan -> Step 2 Open Windows -->
        <div class="trigger-panel" style="margin-bottom: 25px;">
            <h3>ü™Ñ Chu·ªói thao t√°c: B∆∞·ªõc 1 Scan ‚Üí B∆∞·ªõc 2 M·ªü windows</h3>
            <p style="color: #9dabb9; margin-bottom: 12px;">
                B∆∞·ªõc 1: Scan ƒë·ªÉ ƒë·ªìng b·ªô danh s√°ch worktree ƒëang m·ªü tr√™n m√°y. <br>
                B∆∞·ªõc 2: M·ªü to√†n b·ªô c·ª≠a s·ªï chat c·ªßa c√°c agent v·ª´a scan ƒë∆∞·ª£c.
            </p>
            <div style="display: flex; flex-wrap: wrap; gap: 10px; align-items: center; margin-bottom: 12px;">
                <button class="btn btn-primary" onclick="scanWorktrees()">üîç B∆∞·ªõc 1: Scan Active Worktrees</button>
                <button class="btn btn-success" onclick="openAllWorktrees()">ü™ü B∆∞·ªõc 2: Open All Windows</button>
                <small style="color: #9dabb9;">(C·∫ßn scan tr∆∞·ªõc r·ªìi m·ªõi m·ªü windows)</small>
            </div>
            <div id="worktreeScanResult" style="margin-top: 10px; color: #9dabb9;"></div>
            <div id="openAllResult" style="margin-top: 10px; color: #9dabb9;"></div>
        </div>

        <!-- Monitor Tab -->
        <div id="monitor" class="tab-content active">
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-label">Total Tasks</div>
                    <div class="stat-value" id="totalTasks">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Completed</div>
                    <div class="stat-value" id="completedTasks">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">In Progress</div>
                    <div class="stat-value" id="inProgressTasks">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Pending</div>
                    <div class="stat-value" id="pendingTasks">0</div>
                </div>
            </div>

            <div class="agents-grid" id="agentsGrid"></div>
            
            <div class="plan-viewer">
                <h2>üìã Task Board</h2>
                <div id="taskList"></div>
            </div>
        </div>

        <!-- Trigger Tab -->
        <div id="trigger" class="tab-content">
            <div class="trigger-panel">
                <h3>üí¨ Send Message to Agent</h3>
                <p style="color: #9dabb9; margin-bottom: 15px;">
                    G·ª≠i tin nh·∫Øn cho c√°c agent ƒëang c√≥ window m·ªü trong Cursor. Ch·ªâ c√°c agent ƒëang active m·ªõi hi·ªÉn th·ªã trong danh s√°ch.
                </p>
                <div class="trigger-form">
                    <div class="form-group">
                        <label>Select Agent (ƒëang m·ªü):</label>
                        <select id="messageAgentSelect">
                            <option value="">-- Ch·ªçn Agent --</option>
                        </select>
                        <small style="color: #9dabb9; display: block; margin-top: 5px;">
                            üîÑ Danh s√°ch t·ª± ƒë·ªông c·∫≠p nh·∫≠t t·ª´ c√°c window ƒëang m·ªü
                        </small>
                    </div>
                    <div class="form-group">
                        <label>Message:</label>
                        <textarea id="messageText" rows="5" placeholder="Nh·∫≠p tin nh·∫Øn cho agent...&#10;V√≠ d·ª•: ƒê·ªçc shared_state.json v√† cho t√¥i bi·∫øt tasks n√†o ƒëang PENDING"></textarea>
                    </div>
                    <button class="btn btn-primary" onclick="sendMessageToAgent()">üì§ Send Message</button>
                </div>
            </div>
        </div>

    </div>

    <button class="refresh-btn" onclick="loadData()" title="Refresh">üîÑ</button>

    <script>
        let sharedState = null;

        function copyText(txt) {
            navigator.clipboard.writeText(txt).then(() => {
                showNotification('üìã Copied to clipboard', 'success');
            }).catch(() => {
                showNotification('‚ö†Ô∏è Copy failed', 'warning');
            });
        }

        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(tabName).classList.add('active');
        }

        async function loadData() {
            try {
                // ∆Øu ti√™n load t·ª´ API server (port 8001) ƒë·ªÉ c√≥ data m·ªõi nh·∫•t
                let response = null;
                
                // Th·ª≠ API server tr∆∞·ªõc
                try {
                    response = await fetch('http://localhost:8001/api/state', {
                        method: 'GET',
                        headers: { 'Content-Type': 'application/json' },
                        cache: 'no-cache'
                    });
                    if (response.ok) {
                        try {
                            sharedState = await response.json();
                            // Backend ƒë√£ t·ª± sync r·ªìi, ch·ªâ render UI
                            // Kh√¥ng c·∫ßn sync l·∫°i ·ªü frontend v√¨ backend ƒë√£ l√†m r·ªìi
                            renderDashboard();
                            updateLastUpdate();
                            return;
                        } catch (jsonError) {
                            console.error('Failed to parse JSON from /api/state:', jsonError);
                            // Fall through to file paths fallback
                            response = null;
                        }
                    }
                } catch (e) {
                    console.warn('API server not available, trying file paths...', e);
                    response = null;
                }
                
                // Fallback: Load t·ª´ file paths
                const paths = [
                    'shared_state.json',
                    '/.mcp/shared_state.json',
                    '../.mcp/shared_state.json'
                ];
                
                for (const path of paths) {
                    try {
                        response = await fetch(path, { cache: 'no-cache' });
                        if (response.ok) break;
                    } catch (e) {
                        continue;
                    }
                }
                
                if (!response || !response.ok) {
                    throw new Error('Cannot load shared_state.json');
                }
                
                // Parse JSON c·∫©n th·∫≠n ƒë·ªÉ tr√°nh l·ªói "Unexpected end of JSON input"
                try {
                    sharedState = await response.json();
                } catch (parseError) {
                    console.error('Failed to parse shared_state.json:', parseError);
                    throw new Error('Invalid shared_state.json content');
                }
                
                // Backend ƒë√£ t·ª± sync r·ªìi, ch·ªâ render UI
                renderDashboard();
                updateLastUpdate();
            } catch (error) {
                console.error('Error:', error);
                showError('Kh√¥ng th·ªÉ load shared_state.json. ƒê·∫£m b·∫£o API server ƒëang ch·∫°y (port 8001) ho·∫∑c d√πng local server.');
            }
        }
        
        // DEPRECATED: Backend ƒë√£ t·ª± sync r·ªìi, kh√¥ng c·∫ßn sync ·ªü frontend
        // Gi·ªØ l·∫°i h√†m n√†y ƒë·ªÉ t∆∞∆°ng th√≠ch ng∆∞·ª£c (n·∫øu c√≥ code n√†o g·ªçi)
        function syncAgentStatusWithTasks() {
            // Backend ƒë√£ t·ª± sync trong /api/state endpoint
            // Frontend ch·ªâ c·∫ßn hi·ªÉn th·ªã data t·ª´ backend
            return;
        }

        function renderDashboard() {
            if (!sharedState) return;
            renderAgents();
            renderTasks();
            updateStats();
            updateProjectStatus();
            updateTaskSelect();
            renderWorktrees();
            updateMessageAgentSelect(); // C·∫≠p nh·∫≠t select agent d·ª±a tr√™n detected_chats
        }
        
        function updateMessageAgentSelect() {
            const agentSelect = document.getElementById('messageAgentSelect');
            if (!agentSelect) return;
            
            // L·∫•y danh s√°ch agents ƒëang c√≥ window m·ªü t·ª´ detected_chats
            const detectedChats = sharedState?.detected_chats || [];
            const activeAgents = new Set();
            
            detectedChats.forEach(chat => {
                if (chat.agent_name) {
                    activeAgents.add(chat.agent_name);
                }
            });
            
            // GI·ªÆ L·∫†I agent ƒë√£ ch·ªçn tr∆∞·ªõc khi update
            const currentSelectedAgent = agentSelect.value;
            
            // Clear v√† c·∫≠p nh·∫≠t options
            agentSelect.innerHTML = '<option value="">-- Ch·ªçn Agent --</option>';
            
            if (activeAgents.size === 0) {
                agentSelect.innerHTML += '<option value="" disabled>‚ö†Ô∏è Kh√¥ng c√≥ agent n√†o ƒëang m·ªü</option>';
            } else {
                // Sort agents theo th·ª© t·ª± chu·∫©n
                const agentOrder = ['Architect', 'Backend_AI_Dev', 'UI_UX_Dev', 'Testing_QA', 'Supervisor', 'Gemini_3_Pro'];
                const sortedAgents = Array.from(activeAgents).sort((a, b) => {
                    const idxA = agentOrder.indexOf(a);
                    const idxB = agentOrder.indexOf(b);
                    if (idxA === -1 && idxB === -1) return a.localeCompare(b);
                    if (idxA === -1) return 1;
                    if (idxB === -1) return -1;
                    return idxA - idxB;
                });
                
                sortedAgents.forEach(agent => {
                    const option = document.createElement('option');
                    option.value = agent;
                    option.textContent = agent;
                    agentSelect.appendChild(option);
                });
                
                // Kh√¥i ph·ª•c agent ƒë√£ ch·ªçn n·∫øu v·∫´n c√≤n trong danh s√°ch
                if (currentSelectedAgent && activeAgents.has(currentSelectedAgent)) {
                    agentSelect.value = currentSelectedAgent;
                }
            }
            
            console.log(`[updateMessageAgentSelect] C·∫≠p nh·∫≠t ${activeAgents.size} agents ƒëang m·ªü:`, Array.from(activeAgents));
        }

        function renderWorktrees() {
            const worktreesList = document.getElementById('worktreesList');
            if (!worktreesList) return;
            const detectedChats = sharedState?.detected_chats || [];
            
            // Debug log (ch·ªâ log khi c·∫ßn)
            // console.log('renderWorktrees called, detected_chats:', detectedChats.length);
            
            if (detectedChats.length === 0) {
                worktreesList.innerHTML = `
                    <div style="color: #9dabb9; text-align: center; padding: 20px;">
                        No worktrees detected. Click "Scan" to detect active chats.
                    </div>
                `;
                return;
            }
            
            worktreesList.innerHTML = detectedChats.map((chat, idx) => {
                const agentMatch = chat.agent_name 
                    ? `<span class="status-badge status-completed">‚úÖ ${chat.agent_name}</span>`
                    : `<span class="status-badge status-pending">‚ùì Not identified</span>`;
                
                // Get analytics if available
                const analytics = chat.analytics || {};
                const gitStatus = analytics.git_status || {};
                const fileStats = analytics.file_stats || {};
                const hasChanges = gitStatus.has_changes || false;
                const modifiedFiles = fileStats.modified_files || 0;
                const newFiles = fileStats.new_files || 0;
                const linesAdded = fileStats.lines_added || 0;
                const linesDeleted = fileStats.lines_deleted || 0;
                const recentCommits = analytics.recent_commits || [];
                
                return `
                    <div style="background: rgba(255,255,255,0.05); padding: 15px; border-radius: 8px; margin-bottom: 10px; border-left: 3px solid ${hasChanges ? '#10b981' : '#6b7280'};">
                        <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 10px;">
                            <div style="flex: 1;">
                                <div style="font-weight: 600; font-size: 1.05em;">üìÅ ${chat.worktree_id}</div>
                                <div style="font-size: 0.85em; color: #9dabb9; margin-top: 4px;">
                                    ${Math.round(chat.modified_minutes_ago || 0)} min ago
                                </div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">
                                ${agentMatch}
                                ${chat.model ? `<span style="font-size: 0.8em; color: #a78bfa;">ü§ñ ${chat.model}</span>` : ''}
                            </div>
                        </div>
                        ${analytics.analyzed_at ? `
                            <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.1);">
                                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 8px; font-size: 0.85em;">
                                    ${hasChanges ? `
                                        <div style="color: #10b981;">
                                            <strong>üìù ${modifiedFiles + newFiles}</strong> files changed
                                        </div>
                                    ` : `
                                        <div style="color: #6b7280;">
                                            <strong>‚úì</strong> No uncommitted changes
                                        </div>
                                    `}
                                    ${linesAdded > 0 ? `
                                        <div style="color: #10b981;">
                                            <strong>+${linesAdded}</strong> lines added
                                        </div>
                                    ` : ''}
                                    ${linesDeleted > 0 ? `
                                        <div style="color: #ef4444;">
                                            <strong>-${linesDeleted}</strong> lines deleted
                                        </div>
                                    ` : ''}
                                    ${recentCommits.length > 0 ? `
                                        <div style="color: #3b82f6;">
                                            <strong>üì¶ ${recentCommits.length}</strong> commits (24h)
                                        </div>
                                    ` : ''}
                                </div>
                            </div>
                        ` : `
                            <div style="margin-top: 8px; font-size: 0.8em; color: #9dabb9;">
                                Click "Analyze" to see detailed stats
                            </div>
                        `}
                    </div>
                `;
            }).join('');
        }

        function renderAgents() {
            const agentsGrid = document.getElementById('agentsGrid');
            if (!agentsGrid) return;
            
            // L·∫•y danh s√°ch agents ƒëang c√≥ window m·ªü t·ª´ detected_chats
            const detectedChats = sharedState?.detected_chats || [];
            const agents = sharedState?.agents || {};
            
            if (detectedChats.length === 0) {
                agentsGrid.innerHTML = `
                    <div style="grid-column: 1 / -1; text-align: center; padding: 40px; background: rgba(255,255,255,0.05); border-radius: 12px;">
                        <div style="font-size: 2em; margin-bottom: 15px;">üîç</div>
                        <div style="font-weight: 600; margin-bottom: 10px;">Kh√¥ng c√≥ agent n√†o ƒëang m·ªü</div>
                        <div style="color: #9dabb9; font-size: 0.9em;">
                            M·ªü c√°c window agent trong Cursor ƒë·ªÉ hi·ªÉn th·ªã ·ªü ƒë√¢y
                        </div>
                    </div>
                `;
                return;
            }
            
            // T·∫°o map t·ª´ detected_chats ƒë·ªÉ l·∫•y th√¥ng tin agent
            const agentMap = new Map();
            detectedChats.forEach(chat => {
                if (chat.agent_name) {
                    const agentInfo = agents[chat.agent_name] || {};
                    agentMap.set(chat.agent_name, {
                        ...agentInfo,
                        worktree_id: chat.worktree_id,
                        model: chat.model || agentInfo.model,
                        modified_minutes_ago: chat.modified_minutes_ago || 0
                    });
                }
            });
            
            // Helper: check if agent has any IN_PROGRESS task
            const hasInProgressTask = (agentName) => {
                const tasks = sharedState.task_board || [];
                return tasks.some(t => t.owner === agentName && t.status === 'IN_PROGRESS');
            };

            agentsGrid.innerHTML = Array.from(agentMap.entries()).map(([name, agent]) => {
                const workingByRule = (agent.status === 'Working') && hasInProgressTask(name);
                const statusClass = workingByRule ? 'working' : '';
                const statusBadge = workingByRule
                    ? '<span class="status-badge status-working">üîÑ Working</span>'
                    : '<span class="status-badge status-idle">üí§ Idle</span>';
                
                const taskHtml = agent.current_task 
                    ? `<div style="margin-top: 15px; padding: 12px; background: rgba(255,255,255,0.05); border-radius: 8px; border-left: 3px solid #137FEC;">
                        <div style="font-weight: 600; margin-bottom: 5px;">üìå ${agent.current_task}</div>
                       </div>`
                    : '<div style="margin-top: 15px; padding: 12px; background: rgba(255,255,255,0.05); border-radius: 8px;"><div style="color: #9dabb9;">No active task</div></div>';

                const modelBadge = agent.model 
                    ? `<div style="margin-top: 8px; padding: 4px 10px; background: rgba(139, 92, 246, 0.2); border-radius: 12px; font-size: 0.8em; color: #a78bfa; display: inline-block;">ü§ñ ${agent.model}</div>`
                    : '';
                
                const worktreeInfo = agent.worktree_id 
                    ? `<div style="margin-top: 5px; font-size: 0.8em; color: #9dabb9;">üìÅ ${agent.worktree_id} ‚Ä¢ ${Math.round(agent.modified_minutes_ago || 0)} min ago</div>`
                    : '';

                return `
                    <div class="agent-card ${statusClass}">
                        <div class="agent-header">
                            <div>
                                <div class="agent-name">${name}</div>
                                ${agent.role ? `<div style="color: #9dabb9; font-size: 0.9em; margin-top: 5px;">${agent.role}</div>` : ''}
                                ${modelBadge}
                                ${worktreeInfo}
                            </div>
                            ${statusBadge}
                        </div>
                        ${taskHtml}
                        <div class="agent-actions">
                            <button class="btn btn-primary" onclick="triggerAgentByName('${name}')" ${agent.status === 'Working' ? 'disabled' : ''}>
                                ${agent.status === 'Working' ? 'üîÑ Working...' : '‚ñ∂Ô∏è Start'}
                            </button>
                            <button class="btn btn-success" onclick="viewAgentTasks('${name}')">üìã Tasks</button>
                            <div style="display: flex; gap: 5px; flex-wrap: wrap;">
                                <button class="btn btn-secondary" onclick="openAgentWindow('${name}', 1)" style="background: rgba(59,130,246,0.15); border-color: #3b82f6;">
                                    ü™ü Window 1
                                </button>
                                <button class="btn btn-secondary" onclick="openAgentWindow('${name}', 2)" style="background: rgba(59,130,246,0.1); border-color: #3b82f6; font-size: 0.85em; padding: 5px 10px;">
                                    +2
                                </button>
                                <button class="btn btn-secondary" onclick="openAgentWindow('${name}', 3)" style="background: rgba(59,130,246,0.1); border-color: #3b82f6; font-size: 0.85em; padding: 5px 10px;">
                                    +3
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        async function openAgentWindow(agentName, chatIndex = 1) {
            try {
                const chatLabel = chatIndex === 1 ? 'window' : `chat th·ª© ${chatIndex}`;
                showNotification(`ü™ü ƒêang m·ªü ${chatLabel} cho ${agentName}...`, 'info');
                const response = await fetch('http://localhost:8001/api/open-agent-window', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        agent: agentName,
                        chat_index: chatIndex 
                    }),
                    timeout: 15000  // TƒÉng timeout cho vi·ªác m·ªü window m·ªõi
                });
                
                if (!response.ok) {
                    let errorMsg = `HTTP ${response.status}`;
                    try {
                        const errorData = await response.json();
                        errorMsg = errorData.error || errorData.message || errorMsg;
                    } catch (e) {
                        // Ignore JSON parse error for error response
                    }
                    throw new Error(errorMsg);
                }
                
                let data;
                try {
                    data = await response.json();
                } catch (jsonError) {
                    throw new Error('Invalid JSON response from server');
                }
                
                if (data.success) {
                    // L∆∞u worktree_id v√† model v√†o localStorage ƒë·ªÉ d√πng khi g·ª≠i tin nh·∫Øn
                    if (data.worktree_id) {
                        localStorage.setItem(`agent_${agentName}_worktree_id`, data.worktree_id);
                    }
                    if (data.model) {
                        localStorage.setItem(`agent_${agentName}_model`, data.model);
                    }
                    
                    const chatLabel = chatIndex === 1 ? 'window' : `chat th·ª© ${chatIndex}`;
                    showNotification(`‚úÖ ƒê√£ m·ªü ${chatLabel} cho ${agentName}${data.worktree_id ? ` (${data.worktree_id})` : ''}\nüí¨ Chat ƒëang ƒë∆∞·ª£c load...`, 'success');
                } else {
                    showNotification(`‚ùå Kh√¥ng m·ªü ƒë∆∞·ª£c window cho ${agentName}: ${data.error || data.message || 'Unknown error'}`, 'error');
                }
            } catch (e) {
                console.error('openAgentWindow error:', e);
                if (e.name === 'TypeError' && e.message.includes('fetch')) {
                    showNotification(`‚ùå Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn API server. ƒê·∫£m b·∫£o API server ƒëang ch·∫°y (port 8001)`, 'error');
                } else {
                    showNotification(`‚ùå M·ªü window th·∫•t b·∫°i: ${e.message}`, 'error');
                }
            }
        }

        function renderTasks() {
            const tasks = sharedState.task_board || [];
            const taskList = document.getElementById('taskList');
            
            taskList.innerHTML = tasks.map(task => {
                const statusClass = task.status.toLowerCase().replace('_', '-');
                const statusBadge = {
                    'COMPLETED': '<span class="status-badge status-completed">‚úÖ Completed</span>',
                    'IN_PROGRESS': '<span class="status-badge status-in-progress">üîÑ In Progress</span>',
                    'PENDING': '<span class="status-badge status-pending">‚è≥ Pending</span>'
                }[task.status] || '';

                const canTrigger = task.status === 'PENDING' && 
                    (!task.dependency || tasks.find(t => t.id === task.dependency)?.status === 'COMPLETED');

                return `
                    <div class="task-item ${statusClass}">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <span style="font-weight: 700; color: #137FEC;">${task.id}</span>
                            ${statusBadge}
                        </div>
                        <div style="font-weight: 600; margin: 5px 0;">${task.title}</div>
                        ${task.description ? `<div style="color: #9dabb9; font-size: 0.9em; margin-top: 8px;">${task.description}</div>` : ''}
                        <div style="display: flex; gap: 15px; font-size: 0.85em; color: #9dabb9; margin-top: 10px;">
                            <span>üë§ ${task.owner}</span>
                            ${task.dependency ? `<span>üîó Depends on: ${task.dependency}</span>` : ''}
                        </div>
                        <div class="task-actions">
                            ${canTrigger ? `<button class="btn btn-primary" onclick="triggerTask('${task.id}')">üöÄ Trigger</button>` : ''}
                            <button class="btn btn-success" onclick="viewTaskDetails('${task.id}')">üëÅÔ∏è View</button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function updateStats() {
            const tasks = sharedState.task_board || [];
            const total = tasks.length;
            const completed = tasks.filter(t => t.status === 'COMPLETED').length;
            const inProgress = tasks.filter(t => t.status === 'IN_PROGRESS').length;
            const pending = tasks.filter(t => t.status === 'PENDING').length;

            document.getElementById('totalTasks').textContent = total;
            document.getElementById('completedTasks').textContent = completed;
            document.getElementById('inProgressTasks').textContent = inProgress;
            document.getElementById('pendingTasks').textContent = pending;
        }

        function updateProjectStatus() {
            const status = sharedState.project_info?.status || 'Unknown';
            document.getElementById('projectStatus').textContent = status;
        }

        function updateTaskSelect() {
            if (!sharedState) return;

            const taskSelect = document.getElementById('taskSelect');
            // Sau khi ƒë∆°n gi·∫£n h√≥a Trigger tab, element n√†y kh√¥ng c√≤n n·ªØa.
            // N·∫øu kh√¥ng t·ªìn t·∫°i th√¨ b·ªè qua ƒë·ªÉ tr√°nh l·ªói console.
            if (!taskSelect) return;

            const tasks = sharedState.task_board || [];
            const currentAgent = document.getElementById('agentSelect')?.value;

            // ∆Øu ti√™n task PENDING, n·∫øu kh√¥ng c√≥ d√πng IN_PROGRESS
            let available = tasks.filter(t => t.status === 'PENDING');
            if (available.length === 0) {
                available = tasks.filter(t => t.status === 'IN_PROGRESS');
            }

            // N·∫øu ch·ªçn Agent, ∆∞u ti√™n task thu·ªôc Agent ƒë√≥
            if (currentAgent) {
                const owned = available.filter(t => t.owner === currentAgent);
                if (owned.length > 0) {
                    available = owned;
                }
            }

            // N·∫øu v·∫´n kh√¥ng c√≥ task, hi·ªÉn th·ªã option th√¥ng b√°o
            if (available.length === 0) {
                taskSelect.innerHTML = `<option value="">No available tasks</option>`;
                return;
            }

            taskSelect.innerHTML = available
                .map(t => `<option value="${t.id}">${t.id}: ${t.title} (${t.status})</option>`)
                .join('');
        }

        function renderQuickTriggers() {
            const tasks = sharedState.task_board || [];
            const quickTriggers = document.getElementById('quickTriggers');
            
            const pendingTasks = tasks.filter(t => t.status === 'PENDING');
            
            quickTriggers.innerHTML = pendingTasks.map(task => {
                const canTrigger = !task.dependency || 
                    tasks.find(t => t.id === task.dependency)?.status === 'COMPLETED';
                
                return `
                    <div style="background: rgba(255,255,255,0.05); padding: 15px; border-radius: 8px; margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <div style="font-weight: 600;">${task.id}: ${task.title}</div>
                            <div style="font-size: 0.85em; color: #9dabb9; margin-top: 5px;">Owner: ${task.owner}</div>
                        </div>
                        <button class="btn btn-primary" onclick="triggerTask('${task.id}')" ${!canTrigger ? 'disabled' : ''}>
                            ${canTrigger ? 'üöÄ Trigger' : '‚è≥ Waiting'}
                        </button>
                    </div>
                `;
            }).join('') || '<div style="color: #9dabb9; text-align: center; padding: 20px;">No pending tasks</div>';
        }

        function renderPlan() {
            const tasks = sharedState.task_board || [];
            const projectPlan = document.getElementById('projectPlan');
            const taskDependencies = document.getElementById('taskDependencies');
            const workflowView = document.getElementById('workflowView');

            // Project Plan
            projectPlan.innerHTML = tasks.map(task => `
                <div class="plan-item">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <strong>${task.id}</strong>: ${task.title}
                            <div style="font-size: 0.85em; color: #9dabb9; margin-top: 5px;">
                                Owner: ${task.owner} | Status: ${task.status}
                            </div>
                        </div>
                        <span class="status-badge status-${task.status.toLowerCase().replace('_', '-')}">${task.status}</span>
                    </div>
                </div>
            `).join('');

            // Dependencies
            const withDeps = tasks.filter(t => t.dependency);
            taskDependencies.innerHTML = withDeps.map(task => `
                <div class="plan-item">
                    <strong>${task.id}</strong> depends on <strong>${task.dependency}</strong>
                    <div style="font-size: 0.85em; color: #9dabb9; margin-top: 5px;">
                        ${tasks.find(t => t.id === task.dependency)?.status === 'COMPLETED' ? '‚úÖ Ready' : '‚è≥ Waiting'}
                    </div>
                </div>
            `).join('') || '<div style="color: #9dabb9;">No dependencies</div>';

            // Workflow
            const workflow = tasks
                .filter(t => t.status === 'IN_PROGRESS' || t.status === 'PENDING')
                .sort((a, b) => {
                    if (a.status === 'IN_PROGRESS') return -1;
                    if (b.status === 'IN_PROGRESS') return 1;
                    return 0;
                });
            
            workflowView.innerHTML = workflow.map((task, idx) => `
                <div class="plan-item">
                    <div style="display: flex; align-items: center; gap: 15px;">
                        <div style="width: 30px; height: 30px; border-radius: 50%; background: ${task.status === 'IN_PROGRESS' ? '#8b5cf6' : '#6b7280'}; display: flex; align-items: center; justify-content: center; font-weight: 700;">
                            ${idx + 1}
                        </div>
                        <div style="flex: 1;">
                            <strong>${task.id}</strong>: ${task.title}
                            <div style="font-size: 0.85em; color: #9dabb9;">${task.owner}</div>
                        </div>
                        <span class="status-badge status-${task.status.toLowerCase().replace('_', '-')}">${task.status}</span>
                    </div>
                </div>
            `).join('') || '<div style="color: #9dabb9;">All tasks completed!</div>';
        }

        async function triggerAgent() {
            const agent = document.getElementById('agentSelect').value;
            const taskId = document.getElementById('taskSelect').value;
            const command = document.getElementById('triggerCommand').value;

            const task = sharedState.task_board.find(t => t.id === taskId);
            if (!task) {
                showNotification('Task not found', 'error');
                return;
            }

            // Generate trigger command
            const triggerCmd = command || generateTriggerCommand(agent, task);
            
            // Create trigger file via API
            await createTriggerFile(agent, task, triggerCmd);
            
            // Update task status
            updateTaskStatus(taskId, 'IN_PROGRESS', agent);
        }

        async function triggerAgentByName(agentName) {
            const tasks = sharedState.task_board || [];
            const agentTasks = tasks.filter(t => t.owner === agentName && t.status === 'PENDING');
            
            if (agentTasks.length === 0) {
                showNotification(`No pending tasks for ${agentName}`, 'warning');
                return;
            }

            const task = agentTasks[0];
            const command = generateTriggerCommand(agentName, task);
            
            // Create trigger file
            await createTriggerFile(agentName, task, command);
        }

        async function triggerTask(taskId) {
            const task = sharedState.task_board.find(t => t.id === taskId);
            if (!task) return;

            const command = generateTriggerCommand(task.owner, task);
            
            // Create trigger file
            await createTriggerFile(task.owner, task, command);
            
            // Update task status
            updateTaskStatus(taskId, 'IN_PROGRESS', task.owner);
        }

        function generateTriggerCommand(agent, task) {
            const baseIntro = `B·∫°n l√† **Agent ${agent}** trong h·ªá th·ªëng ƒëa agent c·ªßa d·ª± √°n **CheftAi Android + Auto AI Messaging Web**.

Ng·ªØ c·∫£nh ch√≠nh:
- Repo: cheftAi (Flutter + FastAPI + Web dashboard)
- State trung t√¢m: **.mcp/shared_state.json** (agents, task_board, detected_chats, analytics)
- K·∫ø ho·∫°ch chi ti·∫øt: **.cursor/plans/auto-ai-messaging-web.plan.md**
`;

            let roleHint = '';
            if (agent === 'Architect') {
                roleHint = `Vai tr√≤ c·ªßa b·∫°n:
- Planner ‚Äì ƒë·ªçc k·∫ø ho·∫°ch t·ªïng th·ªÉ, chia nh·ªè c√¥ng vi·ªác, ƒë·ªìng b·ªô task_board.
- ∆Øu ti√™n: ƒë·∫£m b·∫£o flow auto messaging + dashboard ho·∫°t ƒë·ªông th·ªëng nh·∫•t.`;
            } else if (agent === 'Backend_AI_Dev') {
                roleHint = `Vai tr√≤ c·ªßa b·∫°n:
- Backend ‚Äì FastAPI, Gemini, Firestore, auto_submit_service.
- ∆Øu ti√™n: API /api/messages, /api/auto-submit, /api/execute-command, auto_submit_service.py.`;
            } else if (agent === 'UI_UX_Dev') {
                roleHint = `Vai tr√≤ c·ªßa b·∫°n:
- UI/UX ‚Äì Web dashboard (dashboard_enhanced.html), Flutter UI.
- ∆Øu ti√™n: tr·∫£i nghi·ªám g·ª≠i message/trigger, hi·ªÉn th·ªã agents/tasks r√µ r√†ng.`;
            } else if (agent === 'Testing_QA') {
                roleHint = `Vai tr√≤ c·ªßa b·∫°n:
- QA ‚Äì Test API, UI, auto-submit, t√≠nh ·ªïn ƒë·ªãnh.
- ∆Øu ti√™n: vi·∫øt/check test plan, t·∫°o k·ªãch b·∫£n test cho to√†n flow web ‚Üí MCP ‚Üí Cursor.`;
            } else if (agent === 'Supervisor') {
                roleHint = `Vai tr√≤ c·ªßa b·∫°n:
- Gi√°m s√°t ‚Äì t·ªïng h·ª£p k·∫øt qu·∫£, ƒë·ªÅ xu·∫•t task m·ªõi, ƒë·∫£m b·∫£o ti·∫øn ƒë·ªô.
- ∆Øu ti√™n: xem to√†n b·ªô task_board, ƒë·ªÅ xu·∫•t/ƒëi·ªÅu ph·ªëi tasks.`;
            } else {
                roleHint = `Vai tr√≤ c·ªßa b·∫°n:
- Chuy√™n gia h·ªó tr·ª£ trong h·ªá th·ªëng ƒëa agent c·ªßa CheftAi.
- H√£y t·∫≠p trung l√†m t·ªët task ƒë∆∞·ª£c giao, kh√¥ng v∆∞·ª£t qu√° scope.`;
            }

            const taskBlock = `Nhi·ªám v·ª• ƒë∆∞·ª£c giao (Task **${task.id}**):
- Ti√™u ƒë·ªÅ: ${task.title}
${task.description ? `- M√¥ t·∫£ th√™m: ${task.description}` : ''}
- Owner (agent): ${task.owner}
`;

            const steps = `üö® QUAN TR·ªåNG: B·∫†N PH·∫¢I L√ÄM VI·ªÜC NGAY, KH√îNG CH·ªú TH√äM L·ªÜNH!

C√°c b∆∞·ªõc b·∫Øt bu·ªôc (L√ÄM NGAY):
1. **ƒê·ªåC NGAY** .mcp/trigger_queue.json ƒë·ªÉ t√¨m trigger cho b·∫°n (agent == "${agent}") v·ªõi status == "pending".
2. **ƒê·ªåC NGAY** .mcp/shared_state.json ƒë·ªÉ hi·ªÉu task **${task.id}** chi ti·∫øt (project_info, agents, task_board).
3. **B·∫ÆT ƒê·∫¶U NGAY** l√†m task **${task.id}** theo ƒë√∫ng vai tr√≤ c·ªßa b·∫°n.
4. **C·∫¨P NH·∫¨T NGAY** khi ƒëang l√†m:
   - task_board[${task.id}].status ‚Üí \"IN_PROGRESS\"
   - agents[\"${agent}\"].status ‚Üí \"Working\"
   - agents[\"${agent}\"].current_task ‚Üí \"${task.id} - ${task.title}\"
5. Khi ho√†n th√†nh:
   - C·∫≠p nh·∫≠t task_board[${task.id}].status ‚Üí \"COMPLETED\"
   - ƒê·∫∑t l·∫°i agents[\"${agent}\"].status ‚Üí \"Idle\" v√† current_task ‚Üí null
   - N·∫øu c·∫ßn, b·ªï sung ghi ch√∫ v√†o docs ho·∫∑c shared_state.json.
6. Ch·ªâ commit/thay ƒë·ªïi file th·∫≠t s·ª± c·∫ßn cho task n√†y, gi·ªØ code s·∫°ch v√† c√≥ c·∫•u tr√∫c.

üö® B·∫ÆT ƒê·∫¶U NGAY - KH√îNG CH·ªú TH√äM:
1. ƒê·ªçc .mcp/trigger_queue.json ‚Üí t√¨m trigger cho b·∫°n
2. ƒê·ªçc .mcp/shared_state.json ‚Üí hi·ªÉu task ${task.id}
3. L√†m task ngay l·∫≠p t·ª©c
4. C·∫≠p nh·∫≠t trigger_queue.json (status: processing ‚Üí completed) v√† shared_state.json (task status: IN_PROGRESS ‚Üí COMPLETED)

H√£y tr·∫£ l·ªùi ngay: "ƒê√£ ƒë·ªçc trigger_queue.json v√† shared_state.json, b·∫Øt ƒë·∫ßu l√†m task ${task.id} ngay."`;

            return `${baseIntro}

${roleHint}

${taskBlock}

${steps}`;
        }

        async function updateTaskStatus(taskId, status, owner) {
            const task = sharedState.task_board.find(t => t.id === taskId);
            if (!task) return;

            try {
                // Update via API
                const response = await fetch('http://localhost:8001/api/update-task', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        task_id: taskId,
                        status: status,
                        owner: owner,
                        title: task.title
                    })
                });

                if (response.ok) {
                    showNotification(`‚úÖ Task ${taskId} updated to ${status}`, 'success');
                    setTimeout(() => loadData(), 500);
                } else {
                    throw new Error('API failed');
                }
            } catch (error) {
                // Fallback: Create trigger file
                await createTriggerFile(owner, task);
            }
        }

        async function createTriggerFile(agent, task, command = null) {
            try {
                const trigger = {
                    id: Date.now(),
                    agent: agent,
                    task_id: task.id,
                    task_title: task.title,
                    command: command || generateTriggerCommand(agent, task),
                    created_at: new Date().toISOString(),
                    status: 'pending'
                };

                const response = await fetch('http://localhost:8001/api/create-trigger', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(trigger)
                });

                if (response.ok) {
                    const result = await response.json();
                    const promptFile = result.prompt_file || `${agent}.md`;
                    showNotification(`‚úÖ Trigger created! ID: ${result.trigger_id}\n\nüìÑ Prompt file ƒë√£ t·∫°o: .mcp/pending_prompts/${promptFile}\n\nƒêang th·ª≠ auto-submit v√†o Cursor chat cho Agent ${agent}...`, 'success');

                    // G·ªçi API auto-submit (best-effort, macOS-only)
                    try {
                        const payload = {
                            agent: agent,
                            prompt_path: `.mcp/pending_prompts/${promptFile}`,
                        };
                        // Th·ª≠ k√®m chat_id n·∫øu ƒë√£ l∆∞u worktree_id
                        const storedWorktree = localStorage.getItem(`agent_${agent}_worktree_id`);
                        if (storedWorktree) {
                            payload.chat_id = storedWorktree;
                        }
                        await fetch('http://localhost:8001/api/auto-submit', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify(payload)
                        });
                    } catch (e) {
                        console.error('Auto-submit failed, fallback to clipboard only', e);
                    }

                    // Lu√¥n copy command v√†o clipboard nh∆∞ backup
                    navigator.clipboard.writeText(trigger.command).then(() => {
                        console.log('Command also copied to clipboard (backup)');
                    });
                } else {
                    throw new Error('API failed');
                }
            } catch (error) {
                // Fallback: copy to clipboard and show instruction
                const cmd = command || generateTriggerCommand(agent, task);
                navigator.clipboard.writeText(cmd).then(() => {
                    showNotification(`‚ö†Ô∏è API server kh√¥ng ch·∫°y. Command ƒë√£ copy!\n\nPaste v√†o ${agent} chat:\n\n${cmd}\n\nHo·∫∑c Agent ƒë·ªçc: .mcp/trigger_queue.json`, 'warning');
                });
            }
        }

        // Helper function ƒë·ªÉ retry auto-submit v·ªõi exponential backoff
        async function retryAutoSubmit(agent, promptFile, chatId, maxRetries = 2) {
            for (let attempt = 0; attempt < maxRetries; attempt++) {
                try {
                    const autoSubmitPayload = {
                        agent: agent,
                        prompt_path: `.mcp/pending_prompts/${promptFile}`
                    };
                    if (chatId) {
                        autoSubmitPayload.chat_id = chatId;
                    }
                    
                    const autoSubmitResponse = await fetch('http://localhost:8001/api/auto-submit', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(autoSubmitPayload)
                    });
                    
                    if (autoSubmitResponse.ok) {
                        const autoResult = await autoSubmitResponse.json();
                        const message = autoResult.message || '';
                        
                        if (autoResult.success && message.includes('sent_to_cursor_ok')) {
                            showNotification(`‚úÖ Message ƒë√£ g·ª≠i t·ªõi ${agent}!\n\nüì§ Message ƒë√£ ƒë∆∞·ª£c paste v√† submit v√†o chat ƒëang m·ªü`, 'success');
                            return true;
                        } else if (autoResult.success) {
                            showNotification(`‚úÖ ƒê√£ focus v√†o Cursor!\n\nüìÑ Prompt file: .mcp/pending_prompts/${promptFile}\n\n‚ö†Ô∏è Message c√≥ th·ªÉ ƒë√£ ƒë∆∞·ª£c g·ª≠i. Ki·ªÉm tra chat.`, 'warning');
                            return true;
                        } else if (attempt < maxRetries - 1) {
                            // Retry v·ªõi delay
                            await new Promise(resolve => setTimeout(resolve, 500 * (attempt + 1)));
                            continue;
                        } else {
                            showNotification(`‚úÖ Prompt file ƒë√£ t·∫°o!\n\nüìÑ File: .mcp/pending_prompts/${promptFile}\n\n‚ö†Ô∏è Auto-submit th·∫•t b·∫°i sau ${maxRetries} l·∫ßn th·ª≠: ${message}\n\nVui l√≤ng m·ªü chat c·ªßa ${agent} v√† ƒë·ªçc prompt file.`, 'warning');
                            return false;
                        }
                    } else {
                        if (attempt < maxRetries - 1) {
                            await new Promise(resolve => setTimeout(resolve, 500 * (attempt + 1)));
                            continue;
                        } else {
                            throw new Error('Auto-submit API failed');
                        }
                    }
                } catch (e) {
                    console.error(`Auto-submit attempt ${attempt + 1} failed:`, e);
                    if (attempt < maxRetries - 1) {
                        await new Promise(resolve => setTimeout(resolve, 500 * (attempt + 1)));
                        continue;
                    } else {
                        showNotification(`‚úÖ Prompt file ƒë√£ t·∫°o!\n\nüìÑ File: .mcp/pending_prompts/${promptFile}\n\n‚ö†Ô∏è Auto-submit th·∫•t b·∫°i sau ${maxRetries} l·∫ßn th·ª≠.\n\nVui l√≤ng m·ªü chat c·ªßa ${agent} v√† ƒë·ªçc prompt file.`, 'warning');
                        return false;
                    }
                }
            }
            return false;
        }

        async function sendMessageToAgent() {
            console.log('sendMessageToAgent() called');
            
            const agentSelect = document.getElementById('messageAgentSelect');
            const messageText = document.getElementById('messageText');
            
            // Debug: Ki·ªÉm tra elements
            if (!agentSelect) {
                console.error('‚ùå messageAgentSelect not found');
                showNotification('‚ùå L·ªói: Kh√¥ng t√¨m th·∫•y dropdown ch·ªçn agent', 'error');
                return;
            }
            
            if (!messageText) {
                console.error('‚ùå messageText not found');
                showNotification('‚ùå L·ªói: Kh√¥ng t√¨m th·∫•y textarea nh·∫≠p message', 'error');
                return;
            }
            
            const agent = agentSelect.value;
            const message = messageText.value.trim();
            
            console.log('Agent:', agent, 'Message:', message);
            
            if (!agent || agent === '-- Ch·ªçn Agent --' || agent === '') {
                showNotification('‚ùå Vui l√≤ng ch·ªçn agent', 'error');
                return;
            }
            
            if (!message) {
                showNotification('‚ùå Vui l√≤ng nh·∫≠p tin nh·∫Øn', 'error');
                return;
            }
            
            // Disable button ƒë·ªÉ tr√°nh double submission
            const sendButton = document.querySelector('button[onclick="sendMessageToAgent()"]');
            if (sendButton) {
                sendButton.disabled = true;
                sendButton.textContent = 'üì§ ƒêang g·ª≠i...';
            } else {
                console.warn('‚ö†Ô∏è Send button not found by selector');
                // Th·ª≠ t√¨m b·∫±ng text content
                const buttons = document.querySelectorAll('button');
                for (let btn of buttons) {
                    if (btn.textContent.includes('Send Message')) {
                        btn.disabled = true;
                        btn.textContent = 'üì§ ƒêang g·ª≠i...';
                        break;
                    }
                }
            }
            
            try {
                showNotification('üîç Auto Test & Fix - ƒêang ki·ªÉm tra...', 'info');
                console.log('Sending message:', { agent, message });
                
                // Auto Test & Fix: Ki·ªÉm tra API server tr∆∞·ªõc
                try {
                    const healthCheck = await fetch('http://localhost:8001/api/state', {
                        method: 'GET',
                        timeout: 3000
                    });
                    if (!healthCheck.ok) {
                        throw new Error('API server not responding');
                    }
                    console.log('‚úÖ API server is running');
                } catch (e) {
                    console.warn('‚ö†Ô∏è API server check failed, but continuing...', e);
                    showNotification('‚ö†Ô∏è API server c√≥ th·ªÉ kh√¥ng ch·∫°y, ƒëang th·ª≠ g·ª≠i message...', 'warning');
                }
                
                showNotification('üì§ ƒêang g·ª≠i tin nh·∫Øn...', 'info');
                
                // L·∫•y worktree_id v√† model t·ª´ localStorage ho·∫∑c detected_chats ƒë·ªÉ ƒë·∫£m b·∫£o g·ª≠i v√†o ƒë√∫ng window
                let worktreeId = localStorage.getItem(`agent_${agent}_worktree_id`);
                let model = localStorage.getItem(`agent_${agent}_model`);
                
                // N·∫øu kh√¥ng c√≥ trong localStorage, t√¨m trong detected_chats
                if (!worktreeId || !model) {
                    const detectedChats = sharedState?.detected_chats || [];
                    const agentChat = detectedChats.find(chat => chat.agent_name === agent);
                    if (agentChat) {
                        worktreeId = worktreeId || agentChat.worktree_id;
                        model = model || agentChat.model;
                        // L∆∞u v√†o localStorage ƒë·ªÉ d√πng l·∫ßn sau
                        if (worktreeId) localStorage.setItem(`agent_${agent}_worktree_id`, worktreeId);
                        if (model) localStorage.setItem(`agent_${agent}_model`, model);
                    }
                }
                
                console.log(`üì§ G·ª≠i tin nh·∫Øn cho ${agent}`, { worktreeId, model });
                
                // Retry logic cho /api/messages v·ªõi auto fix
                let response;
                let lastError;
                for (let attempt = 0; attempt < 3; attempt++) {
                    try {
                        console.log(`Attempt ${attempt + 1}/3: POST /api/messages`);
                        
                        const requestBody = {
                            agent: agent,
                            message: message,
                            task_id: 'ADHOC',
                            task_title: `Message from dashboard`
                        };
                        
                        // Th√™m worktree_id v√† model n·∫øu c√≥ ƒë·ªÉ ƒë·∫£m b·∫£o g·ª≠i v√†o ƒë√∫ng window
                        if (worktreeId) {
                            requestBody.chat_id = worktreeId;
                        }
                        if (model) {
                            requestBody.model = model;
                        }
                        
                        response = await fetch('http://localhost:8001/api/messages', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify(requestBody)
                        });
                        console.log('Response status:', response.status, response.statusText);
                        
                        // N·∫øu response OK, break
                        if (response.ok) {
                            break;
                        }
                        
                        // N·∫øu kh√¥ng OK, th·ª≠ retry
                        if (attempt < 2) {
                            const errorText = await response.text();
                            console.warn(`Attempt ${attempt + 1} failed with status ${response.status}, retrying...`);
                            await new Promise(resolve => setTimeout(resolve, 1000 * (attempt + 1)));
                            continue;
                        } else {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }
                    } catch (e) {
                        console.error(`Attempt ${attempt + 1} failed:`, e);
                        lastError = e;
                        if (attempt < 2) {
                            await new Promise(resolve => setTimeout(resolve, 1000 * (attempt + 1)));
                            continue;
                        } else {
                            throw e;
                        }
                    }
                }
                
                if (response.ok) {
                    let result;
                    try {
                        result = await response.json();
                        console.log('API response:', result);
                    } catch (e) {
                        console.error('Failed to parse JSON response:', e);
                        const text = await response.text();
                        console.error('Response text:', text);
                        throw new Error('Invalid JSON response from server');
                    }
                    
                    const promptFile = result.prompt_file || `${agent}.md`;
                    console.log('Prompt file:', promptFile);
                    console.log('Auto submit result:', result.auto_submit);
                    
                    // Clear message textarea (NH∆ØNG GI·ªÆ L·∫†I AGENT ƒê√É CH·ªåN ƒë·ªÉ ti·ªán g·ª≠i ti·∫øp)
                    messageText.value = '';
                    // Focus v√†o textarea ƒë·ªÉ user c√≥ th·ªÉ g·ª≠i ti·∫øp ngay
                    messageText.focus();
                    
                    // Ki·ªÉm tra xem /api/messages ƒë√£ auto-submit th√†nh c√¥ng ch∆∞a
                    const autoSubmitResult = result.auto_submit;
                    console.log('Processing auto_submit result:', autoSubmitResult);
                    
                    // Verify message was sent (check prompt file)
                    let verified = false;
                    try {
                        const verifyResponse = await fetch(`http://localhost:8001/api/prompt/${agent}`, {
                            method: 'GET',
                            timeout: 3000
                        });
                        if (verifyResponse.ok) {
                            const promptText = await verifyResponse.text();
                            if (promptText && promptText.length > 100) {
                                verified = true;
                                console.log('‚úÖ Prompt file verified:', promptText.length, 'bytes');
                            }
                        }
                    } catch (e) {
                        console.warn('‚ö†Ô∏è Could not verify prompt file:', e);
                    }
                    
                    // N·∫øu auto_submit b·ªã skip (kh√¥ng ph·∫£i macOS ho·∫∑c kh√¥ng c√≥ ƒëi·ªÅu ki·ªán)
                    if (autoSubmitResult && autoSubmitResult.skipped) {
                        // Backend ƒë√£ skip auto-submit, frontend kh√¥ng c·∫ßn retry
                        if (verified) {
                            showNotification(`‚úÖ Prompt file ƒë√£ t·∫°o v√† verified!\n\nüìÑ File: .mcp/pending_prompts/${promptFile}\n\n‚ö†Ô∏è Auto-submit b·ªã skip (kh√¥ng ph·∫£i macOS ho·∫∑c thi·∫øu ƒëi·ªÅu ki·ªán).\n\nVui l√≤ng m·ªü chat c·ªßa ${agent} v√† ƒë·ªçc prompt file.`, 'warning');
                        } else {
                            showNotification(`‚úÖ Prompt file ƒë√£ t·∫°o!\n\nüìÑ File: .mcp/pending_prompts/${promptFile}\n\n‚ö†Ô∏è Auto-submit b·ªã skip. Vui l√≤ng m·ªü chat c·ªßa ${agent} v√† ƒë·ªçc prompt file.`, 'warning');
                        }
                    } else if (autoSubmitResult && autoSubmitResult.success) {
                        // ƒê√£ auto-submit th√†nh c√¥ng t·ª´ /api/messages
                        const message = autoSubmitResult.message || '';
                        if (message.includes('sent_to_cursor_ok')) {
                            if (verified) {
                                showNotification(`‚úÖ Message ƒë√£ g·ª≠i t·ªõi ${agent}!\n\nüì§ Message ƒë√£ ƒë∆∞·ª£c paste v√† submit v√†o chat ƒëang m·ªü\n‚úÖ Prompt file verified`, 'success');
                            } else {
                                showNotification(`‚úÖ Message ƒë√£ g·ª≠i t·ªõi ${agent}!\n\nüì§ Message ƒë√£ ƒë∆∞·ª£c paste v√† submit v√†o chat ƒëang m·ªü`, 'success');
                            }
                        } else {
                            if (verified) {
                                showNotification(`‚úÖ ƒê√£ focus v√†o Cursor!\n\nüìÑ Prompt file: .mcp/pending_prompts/${promptFile}\n‚úÖ Prompt file verified\n\n‚ö†Ô∏è Message c√≥ th·ªÉ ƒë√£ ƒë∆∞·ª£c g·ª≠i. Ki·ªÉm tra chat.`, 'warning');
                            } else {
                                showNotification(`‚úÖ ƒê√£ focus v√†o Cursor!\n\nüìÑ Prompt file: .mcp/pending_prompts/${promptFile}\n\n‚ö†Ô∏è Message c√≥ th·ªÉ ƒë√£ ƒë∆∞·ª£c g·ª≠i. Ki·ªÉm tra chat.`, 'warning');
                            }
                        }
                    } else if (autoSubmitResult && !autoSubmitResult.success && !autoSubmitResult.skipped) {
                        // Auto-submit t·ª´ /api/messages th·∫•t b·∫°i, th·ª≠ l·∫°i v·ªõi /api/auto-submit
                        const chatId = result.chat_id || null;
                        await retryAutoSubmit(agent, promptFile, chatId, 2);
                    } else if (!autoSubmitResult) {
                        // Kh√¥ng c√≥ auto_submit result (legacy response), th·ª≠ g·ªçi /api/auto-submit
                        const chatId = result.chat_id || null;
                        await retryAutoSubmit(agent, promptFile, chatId, 2);
                    }
                    
                    // Reload data ƒë·ªÉ c·∫≠p nh·∫≠t triggers v√† ƒë·ªìng b·ªô (NH∆ØNG GI·ªÆ L·∫†I AGENT ƒê√É CH·ªåN)
                    const selectedAgentBeforeReload = agentSelect.value;
                    setTimeout(() => {
                        loadData().then(() => {
                            // Kh√¥i ph·ª•c agent ƒë√£ ch·ªçn sau khi reload
                            if (selectedAgentBeforeReload && agentSelect.querySelector(`option[value="${selectedAgentBeforeReload}"]`)) {
                                agentSelect.value = selectedAgentBeforeReload;
                                console.log('‚úÖ Agent selection restored:', selectedAgentBeforeReload);
                            }
                        });
                        // Refresh agent status
                        if (typeof renderAgents === 'function') {
                            renderAgents();
                        }
                    }, 1000);
                } else {
                    console.error('Response not OK:', response.status, response.statusText);
                    let errorData;
                    try {
                        const text = await response.text();
                        console.error('Error response text:', text);
                        errorData = JSON.parse(text);
                    } catch (e) {
                        errorData = { error: `HTTP ${response.status}: ${response.statusText}` };
                    }
                    throw new Error(errorData.error || 'API request failed');
                }
            } catch (error) {
                console.error('Error sending message:', error);
                console.error('Error stack:', error.stack);
                showNotification(`‚ùå G·ª≠i tin nh·∫Øn th·∫•t b·∫°i: ${error.message}\n\nVui l√≤ng m·ªü Console (F12) ƒë·ªÉ xem chi ti·∫øt l·ªói.`, 'error');
            } finally {
                // Re-enable button
                console.log('Finally block: Re-enabling button');
                const sendButton = document.querySelector('button[onclick="sendMessageToAgent()"]');
                if (sendButton) {
                    sendButton.disabled = false;
                    sendButton.textContent = 'üì§ Send Message';
                    console.log('‚úÖ Button re-enabled');
                } else {
                    console.warn('‚ö†Ô∏è Send button not found by selector, trying alternative methods');
                    // Th·ª≠ t√¨m b·∫±ng text content
                    const buttons = document.querySelectorAll('button');
                    for (let btn of buttons) {
                        if (btn.textContent.includes('ƒêang g·ª≠i') || btn.textContent.includes('Send Message')) {
                            btn.disabled = false;
                            btn.textContent = 'üì§ Send Message';
                            console.log('‚úÖ Button re-enabled by text content');
                            break;
                        }
                    }
                }
            }
        }

        function viewAgentTasks(agentName) {
            const tasks = sharedState.task_board.filter(t => t.owner === agentName);
            
            if (tasks.length === 0) {
                showNotification(`Kh√¥ng c√≥ tasks n√†o cho ${agentName}`, 'warning');
                return;
            }

            // T·∫°o modal overlay
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            overlay.onclick = (e) => {
                if (e.target === overlay) {
                    document.body.removeChild(overlay);
                }
            };

            // T·∫°o modal content
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.onclick = (e) => e.stopPropagation();

            // Header
            const header = document.createElement('div');
            header.className = 'modal-header';
            header.innerHTML = `
                <div class="modal-title">üìã Tasks for ${agentName}</div>
                <button class="modal-close" onclick="document.body.removeChild(this.closest('.modal-overlay'))">√ó</button>
            `;

            // Body
            const body = document.createElement('div');
            body.className = 'modal-body';
            
            tasks.forEach(task => {
                const taskItem = document.createElement('div');
                const statusClass = task.status.toLowerCase().replace('_', '-');
                taskItem.className = `task-item ${statusClass}`;
                
                const statusBadge = {
                    'COMPLETED': '‚úÖ COMPLETED',
                    'IN_PROGRESS': 'üîÑ IN_PROGRESS',
                    'PENDING': '‚è≥ PENDING'
                }[task.status] || task.status;
                
                taskItem.innerHTML = `
                    <div class="task-title">
                        <span class="task-id">${task.id}</span>
                        ${task.title}
                    </div>
                    <div class="task-status">${statusBadge}</div>
                `;
                
                body.appendChild(taskItem);
            });

            // Footer
            const footer = document.createElement('div');
            footer.className = 'modal-footer';
            footer.innerHTML = `
                <button class="btn-modal" onclick="document.body.removeChild(this.closest('.modal-overlay'))">OK</button>
            `;

            modal.appendChild(header);
            modal.appendChild(body);
            modal.appendChild(footer);
            overlay.appendChild(modal);
            document.body.appendChild(overlay);
        }

        function viewTaskDetails(taskId) {
            const task = sharedState.task_board.find(t => t.id === taskId);
            if (!task) return;
            
            const details = `
Task ID: ${task.id}
Title: ${task.title}
Owner: ${task.owner}
Status: ${task.status}
${task.dependency ? `Dependency: ${task.dependency}` : ''}
${task.description ? `Description: ${task.description}` : ''}
${task.completed_files ? `Files: ${task.completed_files.join(', ')}` : ''}
            `;
            alert(details);
        }

        function showNotification(message, type = 'success') {
            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.style.background = type === 'error' ? '#ef4444' : type === 'warning' ? '#f59e0b' : '#10b981';
            notification.textContent = message;
            notification.style.whiteSpace = 'pre-line';
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'slideIn 0.3s reverse';
                setTimeout(() => notification.remove(), 300);
            }, 3000);
        }

        function showError(message) {
            document.getElementById('agentsGrid').innerHTML = 
                `<div style="color: #ef4444; text-align: center; padding: 40px; background: rgba(239, 68, 68, 0.1); border-radius: 12px;">
                    <div style="font-size: 2em; margin-bottom: 15px;">‚ùå</div>
                    <div style="font-weight: 600; margin-bottom: 10px;">${message}</div>
                    <div style="font-size: 0.9em; color: #9dabb9; margin-top: 20px;">
                        <strong>Gi·∫£i ph√°p:</strong><br>
                        D√πng local server: <code style="background: rgba(255,255,255,0.1); padding: 4px 8px; border-radius: 4px;">./scripts/open_dashboard.sh</code><br>
                        Ho·∫∑c: <code style="background: rgba(255,255,255,0.1); padding: 4px 8px; border-radius: 4px;">http://localhost:8000/.mcp/dashboard_enhanced.html</code>
                    </div>
                </div>`;
        }

        function updateLastUpdate() {
            document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString('vi-VN');
        }

        // Auto-refresh v·ªõi countdown (ch·ªâ m·ªôt interval)
        let countdown = 5;
        setInterval(() => {
            countdown--;
            const countdownEl = document.getElementById('countdown');
            if (countdownEl) {
                countdownEl.textContent = countdown;
            }
            if (countdown <= 0) {
                loadData();
                countdown = 5;
            }
        }, 1000);

        // Initial load
        loadData();

        // Worktree Scan Function
        async function scanWorktrees() {
            const resultDiv = document.getElementById('worktreeScanResult');
            resultDiv.innerHTML = '<div style="color: #9dabb9;">üîÑ Scanning...</div>';
            
            try {
                const response = await fetch('http://localhost:8001/api/scan-worktrees', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    const chats = data.detected_chats || [];
                    const identified = chats.filter(c => c.agent_name);
                    const unknown = chats.filter(c => !c.agent_name);
                    const curlCmd = 'curl -X POST http://localhost:8001/api/scan-worktrees';
                    const totalCount = data.chat_count || chats.length;

                    if (chats.length > 0) {
                        resultDiv.innerHTML = `
                            <div style="background: rgba(16, 185, 129, 0.1); padding: 15px; border-radius: 8px; border-left: 3px solid #10b981; margin-bottom: 10px;">
                                <div style="font-weight: 600; margin-bottom: 10px;">‚úÖ Detected ${totalCount} active worktree(s):</div>
                                ${identified.length ? `
                                    <div style="margin-bottom: 10px; color: #10b981; font-weight: 600;">Mapped (${identified.length}):</div>
                                    ${identified.map(chat => `
                                        <div style="padding: 8px; background: rgba(255,255,255,0.05); border-radius: 4px; margin-bottom: 5px; display: flex; justify-content: space-between;">
                                            <span><strong>${chat.worktree_id}</strong></span>
                                            <span style="color: #9dabb9;">${Math.round((chat.modified_minutes_ago || 0))} min ago${chat.from_agents ? ' (from agents)' : ''}</span>
                                            <span style="color: #10b981;">‚Üí ${chat.agent_name}</span>
                                        </div>
                                    `).join('')}
                                ` : ''}
                                ${unknown.length ? `
                                    <div style="margin-top: 10px; margin-bottom: 6px; color: #f59e0b; font-weight: 600;">Unknown / Not identified (${unknown.length}):</div>
                                    ${unknown.map(chat => `
                                        <div style="padding: 8px; background: rgba(255,255,255,0.03); border-radius: 4px; margin-bottom: 5px; display: flex; justify-content: space-between;">
                                            <span><strong>${chat.worktree_id}</strong></span>
                                            <span style="color: #9dabb9;">${Math.round((chat.modified_minutes_ago || 0))} min ago</span>
                                            <span style="color: #f59e0b;">Not identified</span>
                                        </div>
                                    `).join('')}
                                    <div style="color: #9dabb9; font-size: 0.9em; margin-top: 6px;">
                                        üí° M·ªü ƒë√∫ng c·ª≠a s·ªï chat agent (n√∫t ‚ÄúWindow 1/+2/+3‚Äù tr√™n Monitor) r·ªìi scan l·∫°i, ho·∫∑c ch·∫°y l·ªánh mark trong worktree ƒë·ªÉ g√°n agent.
                                    </div>
                                ` : ''}
                            </div>
                            <div style="font-size: 0.9em; color: #9dabb9; margin-top: 6px;">
                                Backend scan (detect_active_agents.py scan) ‚Äî API: /api/scan-worktrees<br>
                                cURL: <code style="background: rgba(255,255,255,0.07); padding: 4px 8px; border-radius: 4px;">${curlCmd}</code>
                                <button class="btn btn-primary" style="padding: 4px 10px; margin-left: 8px;" onclick="copyText('${curlCmd}')">Copy</button>
                            </div>
                        `;
                        
                        // Reload dashboard data
                        setTimeout(() => loadData(), 500);
                        
                        if (data.analytics_updated) {
                            resultDiv.innerHTML += '<div style="margin-top: 10px; color: #3b82f6;">üìä Analytics updated automatically</div>';
                        }
                    } else {
                        resultDiv.innerHTML = '<div style="color: #f59e0b;">‚ö†Ô∏è No active worktrees found</div>';
                    }
                } else {
                    throw new Error('API request failed');
                }
            } catch (error) {
                resultDiv.innerHTML = `
                    <div style="color: #ef4444;">
                        ‚ùå Scan failed. Make sure API server is running:<br>
                        <code style="background: rgba(255,255,255,0.1); padding: 4px 8px; border-radius: 4px;">python3 .mcp/api_server.py</code>
                    </div>
                `;
            }
        }

        // Open all worktrees (requires scan first)
        async function openAllWorktrees() {
            const resultDiv = document.getElementById('openAllResult');
            resultDiv.innerHTML = '<div style="color: #9dabb9;">üîÑ Opening all worktree windows...</div>';

            try {
                const response = await fetch('http://localhost:8001/api/open-all-worktrees', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });

                if (response.ok) {
                    const data = await response.json();
                    const results = data.results || [];
                    const total = data.total || results.length || 0;
                    const success = results.filter(r => r.success);
                    const failed = results.filter(r => !r.success);

                    resultDiv.innerHTML = `
                        <div style="background: rgba(16, 185, 129, 0.1); padding: 12px; border-radius: 8px; border-left: 3px solid #10b981; margin-bottom: 8px;">
                            ‚úÖ Opened: ${success.length}/${total}
                        </div>
                        ${failed.length ? `
                            <div style="background: rgba(239, 68, 68, 0.08); padding: 12px; border-radius: 8px; border-left: 3px solid #ef4444;">
                                ‚ö†Ô∏è Failed: ${failed.map(f => f.worktree_id || f.agent_name || 'unknown').join(', ')}
                            </div>
                        ` : ''}
                    `;

                    // Reload data after opening to refresh detected_chats/agentsGrid
                    setTimeout(() => loadData(), 800);
                } else {
                    throw new Error('API request failed');
                }
            } catch (error) {
                resultDiv.innerHTML = `
                    <div style="color: #ef4444;">
                        ‚ùå Open-all failed. Make sure API server is running:<br>
                        <code style="background: rgba(255,255,255,0.1); padding: 4px 8px; border-radius: 4px;">python3 .mcp/api_server.py</code>
                    </div>
                `;
            }
        }

        async function analyzeWorktrees() {
            const resultDiv = document.getElementById('worktreeScanResult');
            resultDiv.innerHTML = '<div style="color: #9dabb9;">üìä Analyzing worktrees...</div>';
            
            try {
                const response = await fetch('http://localhost:8001/api/analyze-worktrees', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    
                    if (data.agents_with_analytics && Object.keys(data.agents_with_analytics).length > 0) {
                        resultDiv.innerHTML = `
                            <div style="background: rgba(59, 130, 246, 0.1); padding: 15px; border-radius: 8px; border-left: 3px solid #3b82f6;">
                                <div style="font-weight: 600; margin-bottom: 15px;">üìä Analytics Summary:</div>
                                ${Object.entries(data.agents_with_analytics).map(([agent, stats]) => `
                                    <div style="padding: 10px; background: rgba(255,255,255,0.05); border-radius: 4px; margin-bottom: 8px;">
                                        <div style="font-weight: 600; margin-bottom: 6px;">ü§ñ ${agent}</div>
                                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 8px; font-size: 0.9em;">
                                            ${stats.has_uncommitted_changes ? `
                                                <div style="color: #10b981;">üìù Has uncommitted changes</div>
                                            ` : `
                                                <div style="color: #6b7280;">‚úì No uncommitted changes</div>
                                            `}
                                            ${stats.modified_files > 0 ? `
                                                <div style="color: #10b981;">üìÑ ${stats.modified_files} modified files</div>
                                            ` : ''}
                                            ${stats.new_files > 0 ? `
                                                <div style="color: #3b82f6;">‚ûï ${stats.new_files} new files</div>
                                            ` : ''}
                                            ${stats.lines_added > 0 ? `
                                                <div style="color: #10b981;">+${stats.lines_added} lines</div>
                                            ` : ''}
                                            ${stats.lines_deleted > 0 ? `
                                                <div style="color: #ef4444;">-${stats.lines_deleted} lines</div>
                                            ` : ''}
                                            ${stats.recent_commits_count > 0 ? `
                                                <div style="color: #3b82f6;">üì¶ ${stats.recent_commits_count} commits (24h)</div>
                                            ` : ''}
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        `;
                        
                        // Reload dashboard data to show analytics in Monitor tab
                        setTimeout(() => loadData(), 500);
                    } else {
                        resultDiv.innerHTML = '<div style="color: #f59e0b;">‚ö†Ô∏è No analytics data available. Run scan first.</div>';
                    }
                } else {
                    throw new Error('API request failed');
                }
            } catch (error) {
                resultDiv.innerHTML = `
                    <div style="color: #ef4444;">
                        ‚ùå Analysis failed: ${error.message}<br>
                        Make sure API server is running.
                    </div>
                `;
            }
        }

        // Agent Setup Functions
        const MODEL_OPTIONS = [
            { id: 'Sonnet_4.5', name: 'Sonnet 4.5', suggested: 'Architect' },
            { id: 'GPT_5.1_Codex', name: 'GPT-5.1 Codex High Fast', suggested: 'Backend_AI_Dev' },
            { id: 'Claude_4.1_Opus', name: 'claude-4.1-opus', suggested: 'UI_UX_Dev' },
            { id: 'o3_Pro', name: 'o3 Pro', suggested: 'Testing_QA' },
            { id: 'Sonnet_4_1M', name: 'Sonnet 4 1M', suggested: 'Supervisor' },
        ];

        function renderWorktreeMapping() {
            const form = document.getElementById('worktreeMappingForm');
            const detectedChats = sharedState?.detected_chats || [];
            const agents = sharedState?.agents || {};
            
            if (detectedChats.length === 0) {
                form.innerHTML = '<div style="color: #9dabb9;">Ch∆∞a scan worktrees. Click "Scan Active Worktrees" ·ªü tr√™n.</div>';
                return;
            }
            
            const agentOptions = ['', ...Object.keys(agents)].map(a => 
                `<option value="${a}">${a || '-- Ch·ªçn Agent --'}</option>`
            ).join('');
            
            form.innerHTML = detectedChats.map((chat, idx) => `
                <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 10px; padding: 10px; background: rgba(255,255,255,0.03); border-radius: 8px;">
                    <div style="flex: 1;">
                        <strong>üìÅ ${chat.worktree_id}</strong>
                        <div style="font-size: 0.85em; color: #9dabb9;">${Math.round(chat.modified_minutes_ago || 0)} min ago</div>
                    </div>
                    <select id="wt_map_${chat.worktree_id}" style="padding: 8px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 6px; color: white;">
                        ${agentOptions.replace(`value="${chat.agent_name || ''}"`, `value="${chat.agent_name || ''}" selected`)}
                    </select>
                </div>
            `).join('');
        }

        async function saveWorktreeMapping() {
            const detectedChats = sharedState?.detected_chats || [];
            const mapping = {};
            
            for (const chat of detectedChats) {
                const select = document.getElementById(`wt_map_${chat.worktree_id}`);
                if (select && select.value) {
                    mapping[chat.worktree_id] = select.value;
                }
            }
            
            if (Object.keys(mapping).length === 0) {
                showNotification('‚ö†Ô∏è Ch∆∞a ch·ªçn agent n√†o!', 'warning');
                return;
            }
            
            try {
                const response = await fetch('http://localhost:8001/api/map-worktrees', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ mapping })
                });
                
                if (response.ok) {
                    showNotification(`‚úÖ ƒê√£ l∆∞u mapping cho ${Object.keys(mapping).length} worktree(s)!`, 'success');
                    setTimeout(() => loadData(), 500);
                } else {
                    throw new Error('API failed');
                }
            } catch (error) {
                showNotification(`‚ö†Ô∏è L·ªói: ${error.message}`, 'warning');
            }
        }

        function renderAgentSetup() {
            const form = document.getElementById('agentSetupForm');
            const agents = sharedState?.agents || {};
            const chatCount = sharedState?.chat_count || 5;
            
            document.getElementById('chatCount').textContent = chatCount;
            
            // Also render worktree mapping
            renderWorktreeMapping();
            
            // Add Supervisor if not exists
            const allAgents = { ...agents };
            if (!allAgents['Supervisor']) {
                allAgents['Supervisor'] = { status: 'Idle', current_task: null };
            }
            
            form.innerHTML = Object.entries(allAgents).map(([name, agent]) => {
                const currentModel = agent.model || '';
                const modelOptions = MODEL_OPTIONS.map(m => 
                    `<option value="${m.id}" ${currentModel === m.name ? 'selected' : ''} ${m.suggested === name ? 'style="font-weight:bold"' : ''}>
                        ${m.name} ${m.suggested === name ? '(G·ª£i √Ω)' : ''}
                    </option>`
                ).join('');
                
                return `
                    <div class="form-group" style="background: rgba(255,255,255,0.03); padding: 15px; border-radius: 8px; margin-bottom: 10px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <label style="font-size: 1.1em; font-weight: 700;">${name}</label>
                            <span class="status-badge ${agent.status === 'Working' ? 'status-working' : 'status-idle'}">
                                ${agent.status === 'Working' ? 'üîÑ Working' : 'üí§ Idle'}
                            </span>
                        </div>
                        <select id="model_${name}" style="width: 100%;">
                            <option value="">-- Ch·ªçn Model --</option>
                            ${modelOptions}
                        </select>
                        ${agent.model ? `<div style="font-size: 0.85em; color: #10b981; margin-top: 5px;">‚úÖ ƒê√£ set: ${agent.model}</div>` : ''}
                    </div>
                `;
            }).join('');
        }

        async function saveAgentSetup() {
            const agents = sharedState?.agents || {};
            const updates = {};
            
            // Add Supervisor
            const allAgentNames = [...Object.keys(agents), 'Supervisor'];
            
            for (const name of allAgentNames) {
                const select = document.getElementById(`model_${name}`);
                if (select && select.value) {
                    const model = MODEL_OPTIONS.find(m => m.id === select.value);
                    if (model) {
                        updates[name] = model.name;
                    }
                }
            }
            
            if (Object.keys(updates).length === 0) {
                showNotification('‚ö†Ô∏è Ch∆∞a ch·ªçn model n√†o!', 'warning');
                return;
            }
            
            try {
                const response = await fetch('http://localhost:8001/api/update-agents', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ agent_models: updates })
                });
                
                if (response.ok) {
                    showNotification(`‚úÖ ƒê√£ l∆∞u ${Object.keys(updates).length} agent models!`, 'success');
                    setTimeout(() => loadData(), 500);
                } else {
                    throw new Error('API failed');
                }
            } catch (error) {
                // Fallback: show what would be saved
                showNotification(`‚ö†Ô∏è API server kh√¥ng ch·∫°y.\n\nC·∫ßn l∆∞u v√†o shared_state.json:\n${JSON.stringify(updates, null, 2)}`, 'warning');
            }
        }

        // Make functions global
        window.switchTab = switchTab;
        window.triggerAgent = triggerAgent;
        window.triggerAgentByName = triggerAgentByName;
        async function executeTerminalCommand() {
            const commandSelect = document.getElementById('terminalCommandSelect');
            const argsInput = document.getElementById('terminalArgs');
            const outputDiv = document.getElementById('terminalOutput');
            const outputContent = document.getElementById('terminalOutputContent');
            
            const command = commandSelect.value;
            const args = argsInput.value.trim().split(/\s+/).filter(a => a);
            
            if (!command) {
                showNotification('‚ùå Vui l√≤ng ch·ªçn command', 'error');
                return;
            }
            
            try {
                outputDiv.style.display = 'block';
                outputContent.textContent = `üîÑ ƒêang ch·∫°y: ${command}...\n`;
                outputContent.style.color = '#f59e0b';
                
                let payload = {
                    command: command,
                    timeout: 60
                };
                
                // X√°c ƒë·ªãnh lo·∫°i command
                if (command.endsWith('.py')) {
                    payload.type = 'script';
                    if (args.length > 0) {
                        payload.args = args;
                    }
                } else {
                    payload.type = 'api_command';
                }
                
                console.log('Executing terminal command:', payload);
                
                const response = await fetch('http://localhost:8001/api/execute-command', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(payload)
                });
                
                if (response.ok) {
                    const result = await response.json();
                    console.log('Command result:', result);
                    
                    if (result.success) {
                        outputContent.style.color = '#10b981';
                        outputContent.textContent = `‚úÖ Command executed successfully!\n\nüì§ Output:\n${result.output || '(no output)'}\n`;
                        if (result.error) {
                            outputContent.textContent += `\n‚ö†Ô∏è Warnings:\n${result.error}\n`;
                        }
                        showNotification(`‚úÖ Command '${command}' ƒë√£ ch·∫°y th√†nh c√¥ng!`, 'success');
                    } else {
                        outputContent.style.color = '#ef4444';
                        outputContent.textContent = `‚ùå Command failed!\n\nError: ${result.error || 'Unknown error'}\n\nOutput: ${result.output || '(no output)'}\n`;
                        showNotification(`‚ùå Command '${command}' th·∫•t b·∫°i: ${result.error}`, 'error');
                    }
                } else {
                    const errorText = await response.text();
                    outputContent.style.color = '#ef4444';
                    outputContent.textContent = `‚ùå HTTP Error: ${response.status} ${response.statusText}\n\n${errorText}\n`;
                    showNotification(`‚ùå API request failed: ${response.status}`, 'error');
                }
            } catch (error) {
                console.error('Error executing command:', error);
                outputContent.style.color = '#ef4444';
                outputContent.textContent = `‚ùå Error: ${error.message}\n\n${error.stack || ''}\n`;
                showNotification(`‚ùå L·ªói khi ch·∫°y command: ${error.message}`, 'error');
            }
        }

        window.sendMessageToAgent = sendMessageToAgent;
        window.triggerTask = triggerTask;
        window.viewAgentTasks = viewAgentTasks;
        window.viewTaskDetails = viewTaskDetails;
        window.saveAgentSetup = saveAgentSetup;
        window.scanWorktrees = scanWorktrees;
        window.executeTerminalCommand = executeTerminalCommand;
        window.analyzeWorktrees = analyzeWorktrees;
        window.saveWorktreeMapping = saveWorktreeMapping;
    </script>
</body>
</html>

